package nntc.tsvetkova.myapp;

import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.scene.image.Image;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.sql.*;
import java.util.Objects;
import java.util.prefs.Preferences;

public class DatabaseManager {
    private static String URL;
    private static String USER;
    private static String PASSWORD;
    private static String SCHEMA;

    private Preferences prefs;

    private Connection connection;

    // конструктор
    // создали для инициализации prefs на уровне всего класса
    public DatabaseManager() {
        prefs = Preferences.userNodeForPackage(DesktopApplication.class);
    }

    // Метод для подключения к базе данных
    public void connect() throws SQLException {

        URL = String.format(
                "jdbc:postgresql://%s:%s/%s?currentSchema=%s",
                prefs.get("subdAddress", "localhost"),
                prefs.get("subdPort", "5432"),
                prefs.get("subdDbname", "postgres"),
                prefs.get("subdSchema", "public")
        );
        USER = prefs.get("subdUser", "postgres");
        PASSWORD = prefs.get("subdPassword", "postgres");
        SCHEMA = prefs.get("subdSchema", "public");

        connection = DriverManager.getConnection(URL, USER, PASSWORD);
        System.out.println("Успешно подключено к базе данных.");
    }

    // Метод для отключения от базы данных
    public void disconnect() {
        if (connection != null) {
            try {
                connection.close();
                System.out.println("Соединение с базой данных закрыто.");
            } catch (SQLException e) {
                System.out.println("Ошибка при закрытии соединения: " + e.getMessage());
                // Показываем модальное окно с ошибкой
                Platform.runLater(() -> ErrorDialog.showError("Ошибка при закрытии соединения: ", e.getMessage()));
            }
        }
    }

    // Метод развёртывания таблиц базы данных
    public void ensureTablesExists() {
        String ddlQueries = String.format("""
                    CREATE TABLE IF NOT EXISTS %s.service (
                    	id int GENERATED BY DEFAULT AS IDENTITY NOT NULL,
                    	"name" varchar NOT NULL,
                    	description varchar NULL,
                    	CONSTRAINT service_pk PRIMARY KEY (id)
                    );
                
                    CREATE TABLE IF NOT EXISTS %s."storage" (
                    	id int GENERATED ALWAYS AS IDENTITY NOT NULL,
                    	"name" varchar NULL,
                    	price float4 NULL,
                    	quantity int NULL,
                    	description varchar NULL,
                    	CONSTRAINT storage_pk PRIMARY KEY (id)
                    );
                
                    CREATE TABLE IF NOT EXISTS %s.worker (
                    	id int GENERATED ALWAYS AS IDENTITY NOT NULL,
                    	"name" varchar NOT NULL,
                    	email varchar NOT NULL,
                    	CONSTRAINT worker_pk PRIMARY KEY (id),
                    	CONSTRAINT worker_unique UNIQUE (email)
                    );
                
                    CREATE TABLE IF NOT EXISTS %s."admin" (
                    	id int GENERATED ALWAYS AS IDENTITY NOT NULL,
                    	"name" varchar NULL,
                    	email varchar NOT NULL,
                    	CONSTRAINT admin_pk PRIMARY KEY (id),
                    	CONSTRAINT admin_unique UNIQUE (email)
                    );
                
                    CREATE TABLE IF NOT EXISTS %s.client (
                    	id int GENERATED ALWAYS AS IDENTITY NOT NULL,
                    	"name" varchar NULL,
                    	email varchar NULL,
                    	CONSTRAINT client_pk PRIMARY KEY (id),
                    	CONSTRAINT client_unique UNIQUE (email)
                    );
                
                    CREATE TABLE IF NOT EXISTS %s.appointment (
                    	id int4 GENERATED ALWAYS AS IDENTITY NOT NULL,
                    	"time" time NOT NULL,
                    	"date" date NOT NULL,
                    	worker int4 NULL,
                    	client int4 NULL,
                    	service int4 NULL,
                    	"storage" int4 NULL,
                    	CONSTRAINT appointment_pk PRIMARY KEY (id),
                    	CONSTRAINT appointment_client_fk FOREIGN KEY (client) REFERENCES %s.client(id),
                    	CONSTRAINT appointment_service_fk FOREIGN KEY (service) REFERENCES %s.service(id) ON DELETE RESTRICT,
                    	CONSTRAINT appointment_storage_fk FOREIGN KEY ("storage") REFERENCES %s."storage"(id) ON DELETE SET NULL,
                    	CONSTRAINT appointment_worker_fk FOREIGN KEY (worker) REFERENCES %s.worker(id) ON DELETE SET NULL
                    );
                """, SCHEMA, SCHEMA, SCHEMA, SCHEMA, SCHEMA, SCHEMA, SCHEMA, SCHEMA, SCHEMA, SCHEMA);

//        String dmlQueries = String.format("""
//                    INSERT INTO %s.service ("name", description) VALUES\s
//                    ('Массаж', 'Расслабляющий массаж всего тела'),
//                    ('Косметическая процедура', 'Уход за лицом и телом'),
//                    ('Физиотерапия', 'Лечение с помощью физических методов');
//
//                    INSERT INTO %s."storage" ("name", price, quantity, description) VALUES\s
//                    ('Массажное масло', 15.99, 100, 'Масло для массажа различных типов'),
//                    ('Крем для лица', 25.50, 50, 'Увлажняющий крем для лица'),
//                    ('Электрофорезное оборудование', 500.00, 10, 'Оборудование для физиотерапии');
//
//                    INSERT INTO %s.worker ("name", email) VALUES\s
//                    ('Иван Иванов', 'ivan@example.com'),
//                    ('Мария Петрова', 'maria@example.com'),
//                    ('Сергей Сидоров', 'sergey@example.com');
//
//                    INSERT INTO %s."admin" ("name", email) VALUES\s
//                    ('Анна Смирнова', 'anna@example.com'),
//                    ('Олег Кузнецов', 'oleg@example.com'),
//                    ('Елена Васильева', 'elena@example.com');
//
//                    INSERT INTO %s.client ("name", email) VALUES\s
//                    ('Александр Григорьев', 'alexander@example.com'),
//                    ('Татьяна Лебедева', 'tatiana@example.com'),
//                    ('Дмитрий Федоров', 'dmitry@example.com');
//
//                    INSERT INTO %s.appointment ("time", "date", worker, client, service, "storage") VALUES\s
//                    ('10:00:00', '2023-10-01', 1, 1, 1, NULL),
//                    ('14:00:00', '2023-10-02', 2, 2, 2, 1),
//                    ('16:30:00', '2023-10-03', 3, 3, 3, NULL);
//
//                """, SCHEMA, SCHEMA, SCHEMA, SCHEMA, SCHEMA, SCHEMA);
//        System.out.println(ddlQueries);


        try (Statement statement = connection.createStatement()) {
            statement.execute(ddlQueries);// Если нужно, то можно и DML запросы здесь запустить
            System.out.println("Проверка структуры базы данных завершена.");
        } catch (SQLException e) {
            System.out.println("Ошибка при проверке/создании таблицы: " + e.getMessage());
            // Показываем модальное окно с ошибкой
            Platform.runLater(() -> ErrorDialog.showError("Ошибка при проверке/создании таблицы: ", e.getMessage()));
        }
    }

    public void productsInsertData(String name, Float price) {
        String query = String.format("INSERT INTO %s (name, price) VALUES ('%s', %s)", SCHEMA.concat(".products"), name, String.format("%f", price).replace(",", "."));
        try (var preparedStatement = connection.prepareStatement(query)) {
            int rowsInserted = preparedStatement.executeUpdate();
            System.out.println("Добавлено строк: " + rowsInserted);
        } catch (SQLException e) {
            System.out.println("Ошибка при вставке данных: " + e.getMessage());
            // Показываем модальное окно с ошибкой
            Platform.runLater(() -> ErrorDialog.showError("Ошибка при вставке данных: ", e.getMessage()));
        }
    }

    public void productsUpdateData(Integer id, String name, float price) {
        String query = String.format("UPDATE %s SET name='%s', price=%s WHERE id=%d", SCHEMA.concat(".products"), name, String.format("%f", price).replace(",", "."), id);

        System.out.println("QUERY:");
        System.out.println(query);

        try (var preparedStatement = connection.prepareStatement(query)) {
            int rowsUpdated = preparedStatement.executeUpdate();
            System.out.println("Обновлено строк: " + rowsUpdated);
        } catch (SQLException e) {
            System.out.println("Ошибка при изменении данных: " + e.getMessage());
            // Показываем модальное окно с ошибкой
            Platform.runLater(() -> ErrorDialog.showError("Ошибка при изменении данных: ", e.getMessage()));
        }
    }

    public void productsDeleteData(int id) {
        String query = String.format("DELETE FROM %s WHERE id=%d", SCHEMA.concat(".products"), id);

        try (var preparedStatement = connection.prepareStatement(query)) {
            int rowsDeleted = preparedStatement.executeUpdate();
            System.out.println("Удалено строк: " + rowsDeleted);
        } catch (SQLException e) {
            System.out.println("Ошибка при удалении данных: " + e.getMessage());
            // Показываем модальное окно с ошибкой
            Platform.runLater(() -> ErrorDialog.showError("Ошибка при удалении данных: ", e.getMessage()));
        }
    }

    // Пример: Получение данных
    public ObservableList<Product> productsFetchData() {

        ObservableList<Product> re = FXCollections.observableArrayList();

        String query = String.format("SELECT id, name, price FROM %s", SCHEMA.concat(".products"));

        try (var preparedStatement = connection.prepareStatement(query);
             var resultSet = preparedStatement.executeQuery()) {

            while (resultSet.next()) {
                re.add(new Product(resultSet.getInt("id"), resultSet.getString("name"), resultSet.getFloat("price")));
            }

        } catch (SQLException e) {
            System.out.println("Ошибка при выполнении запроса: " + e.getMessage());
            // Показываем модальное окно с ошибкой
            Platform.runLater(() -> ErrorDialog.showError("Ошибка при выполнении запроса: ", e.getMessage()));
        }
        return re;
    }

    public void customersInsertData(String name, String email) {
        String query = String.format("INSERT INTO %s (name, email) VALUES ('%s', '%s')", SCHEMA.concat(".customers"), name, email);
        try (var preparedStatement = connection.prepareStatement(query)) {
            int rowsInserted = preparedStatement.executeUpdate();
            System.out.println("Добавлено строк: " + rowsInserted);
        } catch (SQLException e) {
            System.out.println("Ошибка при вставке данных: " + e.getMessage());
            // Показываем модальное окно с ошибкой
            Platform.runLater(() -> ErrorDialog.showError("Ошибка при вставке данных: ", e.getMessage()));
        }
    }

    public void customersUpdateData(Integer id, String name, String email) {
        String query = String.format("UPDATE %s SET name='%s', email='%s' WHERE id=%d", SCHEMA.concat(".customers"), name, email, id);

        System.out.println("QUERY:");
        System.out.println(query);

        try (var preparedStatement = connection.prepareStatement(query)) {
            int rowsUpdated = preparedStatement.executeUpdate();
            System.out.println("Обновлено строк: " + rowsUpdated);
        } catch (SQLException e) {
            System.out.println("Ошибка при изменении данных: " + e.getMessage());
            // Показываем модальное окно с ошибкой
            Platform.runLater(() -> ErrorDialog.showError("Ошибка при изменении данных: ", e.getMessage()));
        }
    }

    public void customersDeleteData(int id) {
        String query = String.format("DELETE FROM %s WHERE id=%d", SCHEMA.concat(".customers"), id);

        try (var preparedStatement = connection.prepareStatement(query)) {
            int rowsDeleted = preparedStatement.executeUpdate();
            System.out.println("Удалено строк: " + rowsDeleted);
        } catch (SQLException e) {
            System.out.println("Ошибка при удалении данных: " + e.getMessage());
            // Показываем модальное окно с ошибкой
            Platform.runLater(() -> ErrorDialog.showError("Ошибка при удалении данных: ", e.getMessage()));
        }
    }

    // Пример: Получение данных
    public ObservableList<Customer> customersFetchData() {

        ObservableList<Customer> re = FXCollections.observableArrayList();

        String query = String.format("SELECT id, name, email FROM %s", SCHEMA.concat(".customers"));

        try (var preparedStatement = connection.prepareStatement(query);
             var resultSet = preparedStatement.executeQuery()) {

            while (resultSet.next()) {
                re.add(new Customer(resultSet.getInt("id"), resultSet.getString("name"), resultSet.getString("email")));
            }

        } catch (SQLException e) {
            System.out.println("Ошибка при выполнении запроса: " + e.getMessage());
            // Показываем модальное окно с ошибкой
            Platform.runLater(() -> ErrorDialog.showError("Ошибка при выполнении запроса: ", e.getMessage()));
        }
        return re;
    }

    public void workerInsertData(String name, String email) {
        String query = String.format("INSERT INTO %s (name, email) VALUES ('%s', %s)", SCHEMA.concat(".worker"), name, email);
        try (var preparedStatement = connection.prepareStatement(query)) {
            int rowsInserted = preparedStatement.executeUpdate();
            System.out.println("Добавлено строк: " + rowsInserted);
        } catch (SQLException e) {
            System.out.println("Ошибка при вставке данных: " + e.getMessage());
            // Показываем модальное окно с ошибкой
            Platform.runLater(() -> ErrorDialog.showError("Ошибка при вставке данных: ", e.getMessage()));
        }
    }

    public void workerUpdateData(Integer id, String name, String email) {
        String query = String.format("UPDATE %s SET name='%s', email=%s WHERE id=%d", SCHEMA.concat(".worker"), name, email, id);

        System.out.println("QUERY:");
        System.out.println(query);

        try (var preparedStatement = connection.prepareStatement(query)) {
            int rowsUpdated = preparedStatement.executeUpdate();
            System.out.println("Обновлено строк: " + rowsUpdated);
        } catch (SQLException e) {
            System.out.println("Ошибка при изменении данных: " + e.getMessage());
            // Показываем модальное окно с ошибкой
            Platform.runLater(() -> ErrorDialog.showError("Ошибка при изменении данных: ", e.getMessage()));
        }
    }

    public void workerDeleteData(int id) {
        String query = String.format("DELETE FROM %s WHERE id=%d", SCHEMA.concat(".worker"), id);

        try (var preparedStatement = connection.prepareStatement(query)) {
            int rowsDeleted = preparedStatement.executeUpdate();
            System.out.println("Удалено строк: " + rowsDeleted);
        } catch (SQLException e) {
            System.out.println("Ошибка при удалении данных: " + e.getMessage());
            // Показываем модальное окно с ошибкой
            Platform.runLater(() -> ErrorDialog.showError("Ошибка при удалении данных: ", e.getMessage()));
        }
    }

    // Пример: Получение данных
    public ObservableList<Worker> workerFetchData() {

        ObservableList<Worker> re = FXCollections.observableArrayList();
        String query = String.format("SELECT id, name, email FROM %s", SCHEMA.concat(".worker"));

        try (var preparedStatement = connection.prepareStatement(query);
             var resultSet = preparedStatement.executeQuery()) {

            while (resultSet.next()) {
                re.add(new Worker(resultSet.getInt("id"), resultSet.getString("name"), resultSet.getString("email")));
            }

        } catch (SQLException e) {
            System.out.println("Ошибка при выполнении запроса: " + e.getMessage());
            // Показываем модальное окно с ошибкой
            Platform.runLater(() -> ErrorDialog.showError("Ошибка при выполнении запроса: ", e.getMessage()));
        }
        return re;
    }

    public boolean saveProductImage(File file, int productId) {
        String query = "UPDATE " + SCHEMA.concat(".products") + " SET image_data = ? WHERE id = ?";
        try (
                InputStream inputStream = new FileInputStream(file);
                var preparedStatement = connection.prepareStatement(query)
        ) {
            preparedStatement.setBinaryStream(1, inputStream, (int) file.length());
            preparedStatement.setInt(2, productId);
            int affectedRows = preparedStatement.executeUpdate();
            return affectedRows > 0;
        } catch (Exception e) {
            System.out.println("Ошибка при обновлении изображения: " + e.getMessage());
            // Показываем модальное окно с ошибкой
            Platform.runLater(() -> ErrorDialog.showError("Ошибка при обновлении изображения: ", e.getMessage()));
        }
        return false;
    }

    public Image getProductImage(int productId) {
        String query = "SELECT image_data FROM " + SCHEMA.concat(".products") + " WHERE id = ?";
        try (var preparedStatement = connection.prepareStatement(query)) {
            preparedStatement.setInt(1, productId);
            ResultSet resultSet = preparedStatement.executeQuery();
            if (resultSet.next()) {
                InputStream inputStream = resultSet.getBinaryStream("image_data");
                if (inputStream != null) {
                    return new Image(inputStream);
                }
            }
        } catch (Exception e) {
            System.out.println("Ошибка при получении изображения: " + e.getMessage());
            // Показываем модальное окно с ошибкой
            Platform.runLater(() -> ErrorDialog.showError("Ошибка при получении изображения: ", e.getMessage()));
        }
        InputStream defaultImageStream = getClass().getResourceAsStream("/noimage.jpg");
        return new Image(Objects.requireNonNull(defaultImageStream));
    }

    public ObservableList<Worker> appointmentFetchData() {

        ObservableList<Worker> re = FXCollections.observableArrayList();
        String query = String.format("SELECT id, name, email FROM %s", SCHEMA.concat(".worker"));

        try (var preparedStatement = connection.prepareStatement(query);
             var resultSet = preparedStatement.executeQuery()) {

            while (resultSet.next()) {
                re.add(new Worker(resultSet.getInt("id"), resultSet.getString("name"), resultSet.getString("email")));
            }

        } catch (SQLException e) {
            System.out.println("Ошибка при выполнении запроса: " + e.getMessage());
            // Показываем модальное окно с ошибкой
            Platform.runLater(() -> ErrorDialog.showError("Ошибка при выполнении запроса: ", e.getMessage()));
        }
        return re;
    }

}
